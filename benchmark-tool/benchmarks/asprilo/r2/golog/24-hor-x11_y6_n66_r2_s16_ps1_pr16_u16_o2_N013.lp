#const horizon=24.


init(object(highway,1),value(at,(1,1))).
init(object(highway,2),value(at,(2,1))).
init(object(highway,3),value(at,(3,1))).
init(object(highway,4),value(at,(4,1))).
init(object(highway,5),value(at,(5,1))).
init(object(highway,7),value(at,(7,1))).
init(object(highway,8),value(at,(8,1))).
init(object(highway,9),value(at,(9,1))).
init(object(highway,10),value(at,(10,1))).
init(object(highway,11),value(at,(11,1))).
init(object(highway,12),value(at,(1,2))).
init(object(highway,13),value(at,(2,2))).
init(object(highway,14),value(at,(3,2))).
init(object(highway,15),value(at,(4,2))).
init(object(highway,16),value(at,(5,2))).
init(object(highway,17),value(at,(6,2))).
init(object(highway,18),value(at,(7,2))).
init(object(highway,19),value(at,(8,2))).
init(object(highway,20),value(at,(9,2))).
init(object(highway,21),value(at,(10,2))).
init(object(highway,22),value(at,(11,2))).
init(object(highway,23),value(at,(1,3))).
init(object(highway,28),value(at,(6,3))).
init(object(highway,33),value(at,(11,3))).
init(object(highway,34),value(at,(1,4))).
init(object(highway,39),value(at,(6,4))).
init(object(highway,44),value(at,(11,4))).
init(object(highway,45),value(at,(1,5))).
init(object(highway,46),value(at,(2,5))).
init(object(highway,47),value(at,(3,5))).
init(object(highway,48),value(at,(4,5))).
init(object(highway,49),value(at,(5,5))).
init(object(highway,50),value(at,(6,5))).
init(object(highway,51),value(at,(7,5))).
init(object(highway,52),value(at,(8,5))).
init(object(highway,53),value(at,(9,5))).
init(object(highway,54),value(at,(10,5))).
init(object(highway,55),value(at,(11,5))).
init(object(highway,58),value(at,(3,6))).
init(object(highway,59),value(at,(4,6))).
init(object(highway,60),value(at,(5,6))).
init(object(highway,61),value(at,(6,6))).
init(object(highway,62),value(at,(7,6))).
init(object(highway,63),value(at,(8,6))).
init(object(highway,64),value(at,(9,6))).
init(object(highway,65),value(at,(10,6))).
init(object(highway,66),value(at,(11,6))).
init(object(node,1),value(at,(1,1))).
init(object(node,2),value(at,(2,1))).
init(object(node,3),value(at,(3,1))).
init(object(node,4),value(at,(4,1))).
init(object(node,5),value(at,(5,1))).
init(object(node,6),value(at,(6,1))).
init(object(node,7),value(at,(7,1))).
init(object(node,8),value(at,(8,1))).
init(object(node,9),value(at,(9,1))).
init(object(node,10),value(at,(10,1))).
init(object(node,11),value(at,(11,1))).
init(object(node,12),value(at,(1,2))).
init(object(node,13),value(at,(2,2))).
init(object(node,14),value(at,(3,2))).
init(object(node,15),value(at,(4,2))).
init(object(node,16),value(at,(5,2))).
init(object(node,17),value(at,(6,2))).
init(object(node,18),value(at,(7,2))).
init(object(node,19),value(at,(8,2))).
init(object(node,20),value(at,(9,2))).
init(object(node,21),value(at,(10,2))).
init(object(node,22),value(at,(11,2))).
init(object(node,23),value(at,(1,3))).
init(object(node,24),value(at,(2,3))).
init(object(node,25),value(at,(3,3))).
init(object(node,26),value(at,(4,3))).
init(object(node,27),value(at,(5,3))).
init(object(node,28),value(at,(6,3))).
init(object(node,29),value(at,(7,3))).
init(object(node,30),value(at,(8,3))).
init(object(node,31),value(at,(9,3))).
init(object(node,32),value(at,(10,3))).
init(object(node,33),value(at,(11,3))).
init(object(node,34),value(at,(1,4))).
init(object(node,35),value(at,(2,4))).
init(object(node,36),value(at,(3,4))).
init(object(node,37),value(at,(4,4))).
init(object(node,38),value(at,(5,4))).
init(object(node,39),value(at,(6,4))).
init(object(node,40),value(at,(7,4))).
init(object(node,41),value(at,(8,4))).
init(object(node,42),value(at,(9,4))).
init(object(node,43),value(at,(10,4))).
init(object(node,44),value(at,(11,4))).
init(object(node,45),value(at,(1,5))).
init(object(node,46),value(at,(2,5))).
init(object(node,47),value(at,(3,5))).
init(object(node,48),value(at,(4,5))).
init(object(node,49),value(at,(5,5))).
init(object(node,50),value(at,(6,5))).
init(object(node,51),value(at,(7,5))).
init(object(node,52),value(at,(8,5))).
init(object(node,53),value(at,(9,5))).
init(object(node,54),value(at,(10,5))).
init(object(node,55),value(at,(11,5))).
init(object(node,56),value(at,(1,6))).
init(object(node,57),value(at,(2,6))).
init(object(node,58),value(at,(3,6))).
init(object(node,59),value(at,(4,6))).
init(object(node,60),value(at,(5,6))).
init(object(node,61),value(at,(6,6))).
init(object(node,62),value(at,(7,6))).
init(object(node,63),value(at,(8,6))).
init(object(node,64),value(at,(9,6))).
init(object(node,65),value(at,(10,6))).
init(object(node,66),value(at,(11,6))).
init(object(order,1),value(line,(12,1))).
init(object(order,1),value(pickingStation,1)).
init(object(order,2),value(line,(11,1))).
init(object(order,2),value(pickingStation,1)).
init(object(pickingStation,1),value(at,(6,1))).
init(object(product,1),value(on,(1,1))).
init(object(product,2),value(on,(16,1))).
init(object(product,3),value(on,(15,1))).
init(object(product,4),value(on,(14,1))).
init(object(product,5),value(on,(10,1))).
init(object(product,6),value(on,(2,1))).
init(object(product,7),value(on,(6,1))).
init(object(product,8),value(on,(4,1))).
init(object(product,9),value(on,(3,1))).
init(object(product,10),value(on,(7,1))).
init(object(product,11),value(on,(5,1))).
init(object(product,12),value(on,(8,1))).
init(object(product,13),value(on,(9,1))).
init(object(product,14),value(on,(11,1))).
init(object(product,15),value(on,(13,1))).
init(object(product,16),value(on,(12,1))).
init(object(robot,1),value(at,(1,6))).
init(object(robot,2),value(at,(2,6))).
init(object(shelf,1),value(at,(8,3))).
init(object(shelf,2),value(at,(5,3))).
init(object(shelf,3),value(at,(3,3))).
init(object(shelf,4),value(at,(9,3))).
init(object(shelf,5),value(at,(7,3))).
init(object(shelf,6),value(at,(4,3))).
init(object(shelf,7),value(at,(2,4))).
init(object(shelf,8),value(at,(10,4))).
init(object(shelf,9),value(at,(7,4))).
init(object(shelf,10),value(at,(4,4))).
init(object(shelf,11),value(at,(8,4))).
init(object(shelf,12),value(at,(2,3))).
init(object(shelf,13),value(at,(5,4))).
init(object(shelf,14),value(at,(9,4))).
init(object(shelf,15),value(at,(3,4))).
init(object(shelf,16),value(at,(10,3))).
robot(R) :- init(object(robot,R), _).
shelf(S) :- init(object(shelf,S), _).
station(P) :- init(object(pickingStation,P), _).
product(A) :- init(object(product,A), _).

isRobot(robot(R)) :- robot(R).
isShelf(shelf(S)) :- shelf(S).
isStation(station(T)) :- station(T).
isProduct(product(A)) :- product(A).
isOrder(order(O)) :- order(O).

order(O) :- init(object(order,O), _).
ordered(order(O),product(A)) :- init(object(order,O), value(line,(A,_))). % IGNORING QUANTITIES
target(order(O),station(P)) :- init(object(order,O), value(pickingStation,P)).

shelved(shelf(S),product(A)) :- init(object(product,A), value(on,(S,_))). % IGNORING QUANTITIES

position((X,Y)) :- init(object(node,_), value(at,(X,Y))).

position(station(P),(X,Y)) :- init(object(pickingStation,P), value(at,(X,Y))).

position(robot(R),(X,Y),0) :- init(object(robot,R), value(at,(X,Y))).
position(shelf(S),(X,Y),0) :- init(object(shelf,S), value(at,(X,Y))).

highway(C) :- init(object(highway,_), value(at,C)).


time(0..horizon).

direction((X,Y)) :- X=-1..1, Y=-1..1, |X+Y|=1.
nextto((X,Y),(X',Y'),(X+X',Y+Y')) :- position((X,Y)), direction((X',Y')), position((X+X',Y+Y')).

{ move(R,D,T) : direction(D) ;
pickup(R,S,T) : isShelf(S) ;
putdown(R,S,T) : isShelf(S) } 1 :- isRobot(R), time(T), T<horizon. % T<horizon added by me

waits(R,T) :- not pickup(R,_,T), not putdown(R,_,T), not move(R,_,T), isRobot(R), time(T), T<horizon. % T<horizon added by me

position(R,C,T) :- move(R,D,T), position(R,C',T-1), nextto(C',D,C).
:- move(R,D,T), position(R,C ,T-1), not nextto(C, D,_).

carries(R,S,T) :- pickup(R,S,T).
:- pickup(R,S,T), carries(R,_,T-1).
:- pickup(R,S,T), carries(_,S,T-1). % NEEDED (position of two robots)!?
:- pickup(R,S,T), position(R,C,T-1), not position(S,C,T-1).
:- pickup(R,S,T), position(S,C,T-1), not position(R,C,T-1).

:- putdown(R,S,T), not carries(R,S,T-1).


position(R,C,T) :- position(R,C,T-1), not move(R,_,T), isRobot(R), time(T).
carries(R,S,T) :- carries(R,S,T-1), not putdown(R,S,T), time(T).

position(S,C,T) :- position(R,C,T ), carries(R,S,T).
position(S,C,T) :- position(S,C,T-1), not carries(_,S,T), isShelf(S), time(T).

moveto(C',C,T) :- nextto(C',D,C), position(R,C',T-1), move(R,D,T).
:- moveto(C',C,T), moveto(C,C',T), C < C'.

:- { position(R,C,T) : isRobot(R) } > 1, position(C), time(T).
:- { position(S,C,T) : isShelf(S) } > 1, position(C), time(T).

:- { position(R,C,T) } != 1, isRobot(R), time(T).
:- { position(S,C,T) } != 1, isShelf(S), time(T).

:- { carries(R,S,T) } > 1, isRobot(R), time(T).
:- { carries(R,S,T) } > 1, isShelf(S), time(T).










action(move(R,D)) :- isRobot(R), direction(D).
action(pickup(R,S)) :- isRobot(R), isShelf(S).
action(putdown(R,S)) :- isRobot(R), isShelf(S).
action(wait(R)) :- isRobot(R).



fluent(position(robot(R),(X,Y))) :- position(robot(R),(X,Y),_).
fluent(position(shelf(S),(X,Y))) :- position(shelf(S),(X,Y),_).
fluent(position(station(P),(X,Y))) :- position(station(P),(X,Y)).
fluent(carries(R,S)) :- isRobot(R), isShelf(S).
fluent(contains_ordered_products(S,P,O)) :- isShelf(S), isProduct(P), isOrder(O).
fluent(robot_under_shelf_with_ordered_products(R,S,P,O)) :- isShelf(S), isProduct(P), isOrder(O), isRobot(R).
fluent(shelf_not_on_highway(S)) :- isShelf(S).
fluent(shelf_on_highway(S)) :- isShelf(S).
fluent(not_on_highway(R)) :- isRobot(R).
fluent(all_delivered).
fluent(delivered(O,A)) :- ordered(O,A).
fluent(not_delivered(O,A)) :- ordered(O,A).
fluent(robot_under_shelf(R,S)) :- isRobot(R), isShelf(S).
fluent(robot_on_pickingstation(R)) :- isRobot(R).










agent(X) :- isRobot(X).
performs(R,move(R,D),T) :- move(R,D,T).
performs(R,pickup(R,S),T) :- pickup(R,S,T).
performs(R,putdown(R,S),T) :- putdown(R,S,T).
performs(R,wait(R),T) :- waits(R,T).

holds_for(R,position(R,(X,Y)),T) :- position(R,(X,Y),T), agent(R).
holds_for(R,position(shelf(S),(X,Y)),T) :- position(shelf(S),(X,Y),T), agent(R).
holds_for(R,position(station(P),(X,Y)),T) :- position(station(P),(X,Y)), agent(R), time(T).
holds_for(R,carries(R,S),T) :- carries(R,S,T).
holds_for(R,contains_ordered_products(shelf(S),product(A),order(O)),T) :- shelved(shelf(S),product(A)), ordered(order(O),product(A)), time(T), agent(R).
holds_for(R,robot_under_shelf_with_ordered_products(R,S,P,O),T) :- position(R,C,T), position(S,C,T), isRobot(R), isShelf(S), holds_for(R,contains_ordered_products(S,P,O),T).
holds_for(R,shelf_not_on_highway(S),T) :- highway(C), time(T), not position(S,C,T), isShelf(S), agent(R).
holds_for(R,shelf_on_highway(S),T) :- highway(C), time(T), position(S,C,T), isShelf(S), agent(R).
holds_for(R,not_on_highway(R),T) :- highway(C), time(T), not position(R,C,T), isRobot(R).
holds_for(R,not_delivered(O,A),T) :- ordered(O,A), time(T), not holds_for(R,delivered(O,A),T), agent(R).
holds_for(R,delivered(O,A),T) :- ordered(O,A), target(O,P), position(P,C), shelved(S,A), position(S,C,T), agent(R).
holds_for(R,delivered(O,A),Ta) :- holds_for(R,delivered(O,A),T), time(Ta), Ta > T, agent(R).
holds_for(R,all_delivered,T) :- not holds_for(_,not_delivered(_,_),T), agent(R), time(T).
holds_for(R,all_delivered,Ta) :- holds_for(R,all_delivered,T), time(Ta), Ta > T, agent(R).
holds_for(R,robot_under_shelf(R,S),T) :- position(R,C,T), position(S,C,T), isRobot(R), isShelf(S).
holds_for(R,robot_on_pickingstation(R),T) :- position(R,C,T), position(P,C), isRobot(R).




shift_pointer(X,-1,0,0,0) :- agent(X), not nil.
node_to_visit(X,0,0) :- agent(X), is_node(0).
leaf_to_visit(X,0,0) :- agent(X), is_leaf(0).


is_leaf(I) :- gst(I,A), action(A).
is_leaf(I) :- gst(I,test(_)).
is_node(I) :- not is_leaf(I), gst(I,_).
is_or(I) :- gst(I,or(_,_)).
is_cat(I) :- gst(I,seq(_,_)).
is_star(I) :- gst(I,star(_)).

child_of(C,P) :- gst(P,seq(C,_)).
child_of(C,P) :- gst(P,seq(_,C)).
child_of(C,P) :- gst(P,or(C,_)).
child_of(C,P) :- gst(P,or(_,C)).
child_of(C,P) :- gst(P,star(C)).

nil :- not gst(_,_).

zero_or_more(I) :- is_star(I).
zero_or_more(I) :- child_of(I,P), zero_or_more(P).
zero_or_more(I) :- gst(I, seq(A,B)), zero_or_more(A), zero_or_more(B).
zero_or_more(I) :- is_or(I), child_of(A,I), chosen_alternative(X,A,R), zero_or_more(A), node_to_visit(X,I,R).

1 { end_of_traversal(X,I) : is_leaf(I) } 1 :- agent(X), horizon > 0, not nil.
end_of_traversal(X,P) :- shift_pointer(X,I,P,horizon,R), I<P, is_star(P), R = #max{ R0 : shift_pointer(X,_,I,_,R0) }, horizon = 0.
end_of_traversal(X,0) :- agent(X), is_leaf(0), horizon = 0.


1 { chosen_alternative(X,I,R) : child_of(I,P) } 1 :- is_or(P), shift_pointer(X,N,P,T,R), N<P.
node_to_visit(X,I,R) :- chosen_alternative(X,I,R), shift_pointer(X,_,I,_,R), is_node(I).
leaf_to_visit(X,I,R) :- chosen_alternative(X,I,R), shift_pointer(X,_,I,_,R), is_leaf(I).
node_to_visit(X,A,R) :- shift_pointer(X,I,P,T,R), I<P, gst(P, seq(A,_)), is_node(A).
node_to_visit(X,B,R) :- shift_pointer(X,I,P,T,R), gst(P, seq(_,B)), R = #max{ R0 : shift_pointer(X,I,P,T,R0) }, is_node(B).

node_to_visit(X,I,R) :- node_to_visit(X,P,R), child_of(I,P), is_node(I), not is_star(P), not is_or(P).
leaf_to_visit(X,I,R) :- node_to_visit(X,P,R), child_of(I,P), is_leaf(I), not is_star(P), not is_or(P).

node_to_visit(X,I,R) :- shift_pointer(X,P,I,_,R), is_star(P), child_of(I,P), is_node(I).
leaf_to_visit(X,I,R) :- shift_pointer(X,P,I,_,R), is_star(P), child_of(I,P), is_leaf(I).

visited(X,I,R) :- leaf_to_visit(X,I,R), shift_pointer(X,_,I,_,R), shift_pointer(X,I,_,_,R).
visited(X,I,R) :- node_to_visit(X,I,R), shift_pointer(X,_,I,T,R), shift_pointer(X,I,_,T,R).


holds_for(X,fst_node_formula(F,I),T) :- shift_pointer(X,_,P,T,_), gst(P, test(F)), fst(F,I,A), fluent(A), holds_for(X,A,T).

holds_for(X,fst_node_formula(F,I),T) :- fst(F,I, and(A,B)), holds_for(X,fst_node_formula(F,A),T), holds_for(X,fst_node_formula(F,B),T).

holds_for(X,fst_node_formula(F,I),T) :- fst(F,I, or(A,_)), holds_for(X,fst_node_formula(F,A),T).
holds_for(X,fst_node_formula(F,I),T) :- fst(F,I, or(_,B)), holds_for(X,fst_node_formula(F,B),T).

holds_for(X,fst_node_formula(F,I),T) :- fst(F,I, neg(N)), time(T), agent(X), not holds_for(X,fst_node_formula(F,N),T).


shift_pointer(X,I,P,T,R) :- T<=horizon, shift_pointer(X,P,I,T-1,R), gst(I,A), action(A), performs(X,A,T-1), child_of(I,P), not shift_pointer(X,I,-1,T,R).


shift_pointer(X,I,P,T,R) :- T<=horizon, shift_pointer(X,P,I,T,R), gst(I,test(C)), holds_for(X,fst_node_formula(C,0),T), child_of(I,P), not shift_pointer(X,I,-1,T,R).


shift_pointer(X,P,I,T,R) :- shift_pointer(X,B,P,T,R), gst(P, seq(A,B)), child_of(P,I).

shift_pointer(X,P,A,T,R) :- shift_pointer(X,I,P,T,R), gst(P, seq(A,_)), I<P.
shift_pointer(X,P,B,T,R) :- shift_pointer(X,A,P,T,R), gst(P, seq(A,B)).


shift_pointer(X,P,C,T,R) :- child_of(C,P), chosen_alternative(X,C,R), shift_pointer(X,I,P,T,R), I<P, is_or(P).

shift_pointer(X,P,I,T,R) :- shift_pointer(X,A,P,T,R), gst(P,or(A,_)), child_of(P,I).
shift_pointer(X,P,I,T,R) :- shift_pointer(X,B,P,T,R), gst(P,or(_,B)), child_of(P,I).


{ shift_pointer(X,P,C,T,R+1) } 1 :- shift_pointer(X,I,P,T,R), gst(P,star(C)), I<P, horizon>0.
{ shift_pointer(X,P,C,T,R+1) } 1 :- shift_pointer(X,C,P,T,R), gst(P,star(C)), T>T0, shift_pointer(X,P,C,T0,R). 

{ shift_pointer(X,P,I,T,R) } 1 :- shift_pointer(X,I,P,T,R), gst(P,star(C)), I<P.
{ shift_pointer(X,P,I,T,R0) } 1 :- shift_pointer(X,I,P,T0,R0), I<P, child_of(P,I), shift_pointer(X,C,P,T,R), gst(P,star(C)), R = #max{ N : shift_pointer(X,C,P,_,N) }.


shift_pointer(X,I,-1,horizon,R) :- end_of_traversal(X,I), shift_pointer(X,_,I,horizon-1,R), gst(I,A), action(A), performs(X,A,horizon-1), R = #max{ R0 : shift_pointer(X,_,I,_,R0) }.

shift_pointer(X,I,-1,horizon,R) :- end_of_traversal(X,I), shift_pointer(X,_,I,horizon,R), gst(I,test(C)), holds_for(X,fst_node_formula(C,0),horizon), R = #max{ R0 : shift_pointer(X,_,I,_,R0) }.

shift_pointer(X,P,-1,horizon,R) :- shift_pointer(X,I,P,horizon,R), I<P, is_star(P), R = #max{ R0 : shift_pointer(X,_,I,_,R0) }.


error(1) :- end_of_traversal(X,I), not shift_pointer(X,I,-1,horizon,_), not nil.
error(2) :- leaf_to_visit(X,I,R), not visited(X,I,R), not nil.
error(3) :- node_to_visit(X,I,R), not zero_or_more(I), not visited(X,I,R), not nil.
error(4) :- shift_pointer(X,_,I,T,R), is_leaf(I), not leaf_to_visit(X,I,R), not nil.
error(5) :- gst(P,star(A)), shift_pointer(X,P,A,T,Ra), shift_pointer(X,P,B,T,Rb), B<P, Ra>Rb, not nil.
error(6) :- shift_pointer(X,I,P,T,R), child_of(I,P), shift_pointer(X,I,-1,T,R), not nil.

:- error(_).





gst(0, seq(1,2)).
gst(1, star(3)).
gst(2, seq(4,5)).
gst(3, or(6,7)).
gst(4, test(8)).
gst(5, seq(9,10)).
gst(6, move(R,D)) :- agent(R),direction(D).
gst(7, seq(11,12)).

fst(8, 0, robot_under_shelf_with_ordered_products(R,S,P,O)) :- isRobot(R),isShelf(S),isProduct(P),isOrder(O).

gst(9, pickup(R,S)) :- isRobot(R),isShelf(S).
gst(10, seq(13,14)).
gst(11, test(15)).
gst(12, wait(R)) :- agent(R).
gst(13, star(16)).
gst(14, seq(17,18)).

fst(15, 0, and(1,2)).
fst(15, 1, not_on_highway(R)) :- agent(R).
fst(15, 2, neg(3)).
fst(15, 3, robot_on_pickingstation(R)) :- agent(R).

gst(16, or(19,20)).
gst(17, test(21)).
gst(18, seq(22,23)).
gst(19, move(R,D)) :- agent(R),direction(D).
gst(20, seq(24,25)).

fst(21, 0, and(1,2)).
fst(21, 1, shelf_not_on_highway(S)) :- isShelf(S).
fst(21, 2, neg(3)).
fst(21, 3, robot_on_pickingstation(R)) :- agent(R).

gst(22, putdown(R,S)) :- isRobot(R),isShelf(S).
gst(23, seq(26,27)).
gst(24, test(28)).
gst(25, wait(R)) :- agent(R).
gst(26, test(29)).
gst(27, star(30)).

fst(28, 0, and(1,2)).
fst(28, 1, not_on_highway(R)) :- agent(R).
fst(28, 2, neg(3)).
fst(28, 3, robot_on_pickingstation(R)) :- agent(R).


fst(29, 0, all_delivered).

gst(30, wait(R)) :- agent(R).
#show.
